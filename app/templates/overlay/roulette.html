<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Overlay da Roleta Circular</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@600;700;800&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'Sora', sans-serif;
      background: transparent;
      color: #fff;
      overflow: hidden;
    }
    .panel {
      width: min(980px, 96vw);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(130deg, rgba(15, 23, 42, 0.86), rgba(30, 64, 175, 0.78));
      backdrop-filter: blur(8px);
      box-shadow: 0 24px 48px rgba(2, 6, 23, 0.45);
      padding: 16px;
    }
    .wheel-wrap {
      position: relative;
      width: min(560px, 74vw);
      aspect-ratio: 1 / 1;
      margin: 0 auto;
    }
    .wheel-canvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-shadow: inset 0 0 0 10px rgba(255, 255, 255, 0.94), 0 16px 30px rgba(2, 6, 23, 0.35);
      background: rgba(255, 255, 255, 0.08);
    }
    .wheel-glow {
      animation: wheelGlow 1.1s ease-in-out 3;
    }
    @keyframes wheelGlow {
      0% { box-shadow: inset 0 0 0 10px rgba(255, 255, 255, 0.94), 0 16px 30px rgba(2, 6, 23, 0.35); }
      40% { box-shadow: inset 0 0 0 10px rgba(255, 255, 255, 0.94), 0 0 26px rgba(250, 204, 21, 0.85), 0 0 56px rgba(250, 204, 21, 0.35); }
      100% { box-shadow: inset 0 0 0 10px rgba(255, 255, 255, 0.94), 0 16px 30px rgba(2, 6, 23, 0.35); }
    }
    .pointer {
      position: absolute;
      left: 50%;
      top: -8px;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 18px solid transparent;
      border-right: 18px solid transparent;
      border-top: 34px solid #f97316;
      filter: drop-shadow(0 4px 10px rgba(0,0,0,.35));
      z-index: 5;
    }
    .center-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 92px;
      height: 92px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.95);
      background: radial-gradient(circle at 30% 30%, #a3e635, #65a30d);
      box-shadow: 0 10px 20px rgba(0,0,0,.3);
      z-index: 4;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      line-height: 1.1;
      font-size: 11px;
      font-weight: 800;
      color: #f8fafc;
      padding: 8px;
    }
    .winner-pop { animation: pop .55s ease; }
    @keyframes pop {
      0% { transform: scale(.94); opacity: .65; }
      100% { transform: scale(1); opacity: 1; }
    }
    .winner-toast {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%) scale(0.92);
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 12px;
      font-weight: 800;
      color: #fff;
      background: linear-gradient(120deg, rgba(250, 204, 21, 0.96), rgba(249, 115, 22, 0.96));
      box-shadow: 0 14px 28px rgba(2, 6, 23, 0.42);
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease, transform .22s ease;
      z-index: 7;
      white-space: nowrap;
      max-width: 92%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .winner-toast.show {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }
  </style>
</head>
{% set preview_mode = request.query_params.get('preview') == '1' %}
<body>
  <div class="w-full h-screen flex {% if preview_mode %}items-center{% else %}items-end{% endif %} justify-center {% if preview_mode %}p-2{% else %}p-3 md:p-6{% endif %}">
    <section class="panel">
      {% if preview_mode %}
      <style>
        .panel {
          width: min(420px, 96vw);
          padding: 6px;
          border-radius: 18px;
        }
        .wheel-wrap {
          width: min(250px, 76vw);
        }
      </style>
      {% endif %}
      <header class="flex flex-wrap items-center justify-between gap-2 mb-3 {% if preview_mode %}hidden{% endif %}">
        <h1 id="ov-name" class="text-xl md:text-2xl font-extrabold">Roleta</h1>
        <div class="flex items-center gap-2">
          <span id="ov-status" class="text-xs md:text-sm px-3 py-1 rounded-full bg-red-500">Fechado</span>
          <span class="text-xs md:text-sm rounded-full px-3 py-1 bg-white/10">Comando: <strong id="ov-command">!participar</strong></span>
        </div>
      </header>

      <div class="grid md:grid-cols-3 gap-3 mb-4 {% if preview_mode %}hidden{% endif %}">
        <div class="rounded-xl bg-white/10 p-3">
          <p class="text-[11px] uppercase tracking-wide opacity-80">Participantes</p>
          <p id="ov-count" class="text-3xl md:text-4xl font-extrabold">0</p>
        </div>
        <div id="ov-winner-box" class="rounded-xl border border-amber-300/45 bg-amber-300/15 p-3 md:col-span-2">
          <p class="text-[11px] uppercase tracking-wide opacity-80">Vencedor</p>
          <p id="ov-winner" class="text-xl md:text-2xl font-extrabold">Aguardando sorteio...</p>
        </div>
      </div>

      <div class="wheel-wrap">
        <div class="pointer"></div>
        <canvas id="wheel" class="wheel-canvas" width="700" height="700"></canvas>
        <div class="center-dot">Gire a roleta</div>
        <div id="ov-winner-toast" class="winner-toast"></div>
      </div>
    </section>
  </div>

  <script>
    const giveawayId = {{ giveaway_id }};
    const token = "{{ token }}";
    const previewMode = {{ 'true' if preview_mode else 'false' }};

    const wheel = document.getElementById('wheel');
    const ctx = wheel.getContext('2d');

    const elWinner = document.getElementById('ov-winner');
    const elWinnerBox = document.getElementById('ov-winner-box');
    const elWinnerToast = document.getElementById('ov-winner-toast');

    const baseColors = [
      '#f97316', '#38bdf8', '#facc15', '#a855f7', '#22c55e', '#06b6d4', '#f43f5e', '#84cc16',
      '#0ea5e9', '#eab308', '#14b8a6', '#fb7185', '#6366f1', '#10b981', '#f59e0b', '#8b5cf6'
    ];
    const colorByName = new Map();

    let names = [];
    let namesKey = names.join('|');
    let rotation = 0;
    let angularVelocity = 0.28; // giro lento constante
    let phase = 'idle'; // idle | spinning | resolving
    let resolveAnim = null;
    let lastTs = performance.now();
    let drawStartedAt = 0;
    let pendingWinner = null;
    let plannedDraw = null;
    let winnerKey = null;
    let expectedWinnerName = null;
    let waitingWinnerState = false;
    let initialized = false;
    let audioCtx = null;
    let audioEnabled = true;
    let lastTickIndex = null;
    let holdWinnerUntil = 0;
    let namesLocked = false;

    const fallbackResolveDurationMs = 2600;

    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

    function normalizeAngle(a) {
      const twoPi = Math.PI * 2;
      return ((a % twoPi) + twoPi) % twoPi;
    }

    function stableHash(text) {
      let h = 2166136261;
      const input = String(text || '').toLowerCase();
      for (let i = 0; i < input.length; i += 1) {
        h ^= input.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function colorForName(name) {
      const key = String(name || '');
      if (colorByName.has(key)) return colorByName.get(key);
      const idx = stableHash(key) % baseColors.length;
      const color = baseColors[idx];
      colorByName.set(key, color);
      return color;
    }

    function setWheelNames(nextNames, ensureWinner) {
      const incoming = Array.isArray(nextNames) ? nextNames.slice(0, 80) : [];
      if (ensureWinner && !incoming.includes(ensureWinner)) {
        if (incoming.length >= 80) incoming[incoming.length - 1] = ensureWinner;
        else incoming.push(ensureWinner);
      }
      names = incoming;
      namesKey = incoming.join('|');
      lastTickIndex = null;
    }

    function ensureAudioContext() {
      if (audioCtx || !audioEnabled) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (_) {
        audioEnabled = false;
      }
    }

    function playTickClick() {
      if (!audioEnabled) return;
      ensureAudioContext();
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(() => {});
      }
      try {
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(1600, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.02);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.09, now + 0.003);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.035);
      } catch (_) {
        audioEnabled = false;
      }
    }

    function startSpin() {
      resolveAnim = null;
      phase = 'spinning';
      drawStartedAt = performance.now();
      angularVelocity = Math.max(angularVelocity, 5.5);
    }

    function startResolve(winnerName, durationMs = fallbackResolveDurationMs) {
      if (!winnerName || !names.length) return;

      setWheelNames(names, winnerName);
      const n = names.length;
      const idx = Math.max(names.findIndex((x) => x === winnerName), 0);
      const seg = (Math.PI * 2) / n;

      const current = normalizeAngle(rotation);
      const targetNorm = normalizeAngle(-(idx + 0.5) * seg);
      let delta = targetNorm - current;
      if (delta < 0) delta += Math.PI * 2;

      const extraTurns = Math.PI * 2 * 4;
      resolveAnim = {
        from: rotation,
        to: rotation + delta + extraTurns,
        startedAt: performance.now(),
        duration: durationMs,
      };
      phase = 'resolving';
      if (elWinner) {
        elWinner.textContent = `Sorteando ${winnerName}...`;
      }
    }

    function startPlannedDraw(winnerName, durationMs) {
      if (!winnerName) {
        ensureAudioContext();
        namesLocked = true;
        plannedDraw = {
          winnerName: null,
          totalMs: 1200,
          resolveMs: 0,
          startedAt: performance.now(),
          resolved: false,
          previewOnly: true,
        };
        resolveAnim = null;
        startSpin();
        return;
      }
      const totalMs = Number.isFinite(durationMs) ? Math.max(3000, Math.min(5000, durationMs)) : 4200;
      const resolveMs = Math.min(2200, Math.floor(totalMs * 0.5));
      namesLocked = true;
      expectedWinnerName = winnerName;
      waitingWinnerState = true;
      plannedDraw = {
        winnerName,
        totalMs,
        resolveMs,
        startedAt: performance.now(),
        resolved: false,
        previewOnly: false,
      };
      pendingWinner = winnerName;
      resolveAnim = null;
      ensureAudioContext();
      startSpin();
    }

    function drawWheel() {
      const { width, height } = wheel;
      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(cx, cy) - 10;

      ctx.clearRect(0, 0, width, height);

      const n = names.length;
      if (n === 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.closePath();
        const fill = ctx.createRadialGradient(cx - radius * 0.2, cy - radius * 0.2, radius * 0.2, cx, cy, radius);
        fill.addColorStop(0, '#1e3a8a');
        fill.addColorStop(1, '#0b1229');
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 2;
        ctx.stroke();
        return;
      }

      const seg = (Math.PI * 2) / n;
      const pointerAngle = normalizeAngle(-Math.PI / 2 - rotation);
      const tickIdx = Math.floor(pointerAngle / seg);
      if (lastTickIndex === null) {
        lastTickIndex = tickIdx;
      } else if (tickIdx !== lastTickIndex && (phase === 'spinning' || phase === 'resolving')) {
        playTickClick();
        lastTickIndex = tickIdx;
      }

      for (let i = 0; i < n; i += 1) {
        const start = -Math.PI / 2 + rotation + i * seg;
        const end = start + seg;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, start, end);
        ctx.closePath();
        const label = names[i] || '';
        ctx.fillStyle = colorForName(label);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();

        const labelAngle = start + seg / 2;
        const labelRadius = radius * 0.66;

        ctx.save();
        ctx.translate(cx + Math.cos(labelAngle) * labelRadius, cy + Math.sin(labelAngle) * labelRadius);
        ctx.rotate(labelAngle + Math.PI / 2);
        ctx.fillStyle = '#0f172a';
        const fontSize = Math.max(11, Math.min(24, 360 / n));
        ctx.font = `800 ${fontSize}px Sora, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const clean = String(label).slice(0, 14);
        ctx.fillText(clean, 0, 0);
        ctx.restore();
      }
    }

    function loop(ts) {
      const dt = Math.min((ts - lastTs) / 1000, 0.05);
      lastTs = ts;

      if (phase === 'spinning') {
        angularVelocity = Math.min(angularVelocity + 8 * dt, 11.5);
        rotation += angularVelocity * dt;
        if (plannedDraw && !plannedDraw.resolved) {
          const elapsed = ts - plannedDraw.startedAt;
          if (plannedDraw.previewOnly && elapsed >= plannedDraw.totalMs) {
            plannedDraw.resolved = true;
            plannedDraw = null;
            phase = 'idle';
            angularVelocity = 0.28;
            namesLocked = false;
          } else if (!plannedDraw.previewOnly && elapsed >= (plannedDraw.totalMs - plannedDraw.resolveMs)) {
            plannedDraw.resolved = true;
            startResolve(plannedDraw.winnerName, plannedDraw.resolveMs);
            pendingWinner = null;
          }
        } else if (pendingWinner && (ts - drawStartedAt) >= 2300) {
          startResolve(pendingWinner, fallbackResolveDurationMs);
          pendingWinner = null;
        }
      } else if (phase === 'resolving' && resolveAnim) {
        const t = Math.min((ts - resolveAnim.startedAt) / resolveAnim.duration, 1);
        rotation = resolveAnim.from + (resolveAnim.to - resolveAnim.from) * easeOutCubic(t);
        if (t >= 1) {
          phase = 'idle';
          resolveAnim = null;
          angularVelocity = 0.28;
          holdWinnerUntil = ts + 2000;
          const winnerName = expectedWinnerName || (winnerKey || '').split('|')[0] || 'Vencedor';
          if (elWinner) {
            elWinner.textContent = winnerName;
          }
          if (elWinnerBox) {
            elWinnerBox.classList.remove('winner-pop');
            void elWinnerBox.offsetWidth;
            elWinnerBox.classList.add('winner-pop');
          }
          if (elWinnerToast) {
            elWinnerToast.textContent = `Vencedor: ${winnerName}`;
            elWinnerToast.classList.add('show');
            setTimeout(() => elWinnerToast.classList.remove('show'), 2300);
          }
          wheel.classList.remove('wheel-glow');
          void wheel.offsetWidth;
          wheel.classList.add('wheel-glow');
          plannedDraw = null;
        }
      } else {
        if (ts >= holdWinnerUntil) {
          if (namesLocked) namesLocked = false;
          angularVelocity = 0.28;
          rotation += angularVelocity * dt;
        }
      }

      drawWheel();
      requestAnimationFrame(loop);
    }

    function setBaseState(data) {
      const nameEl = document.getElementById('ov-name');
      const countEl = document.getElementById('ov-count');
      const commandEl = document.getElementById('ov-command');
      if (nameEl) nameEl.textContent = data.name || 'Roleta';
      if (countEl) countEl.textContent = String(data.participants_count || 0);
      if (commandEl) commandEl.textContent = data.command || '!participar';

      const status = document.getElementById('ov-status');
      const open = Boolean(data.is_open);
      if (status) {
        status.textContent = open ? 'Aberto' : 'Fechado';
        status.className = open
          ? 'text-xs md:text-sm px-3 py-1 rounded-full bg-emerald-500'
          : 'text-xs md:text-sm px-3 py-1 rounded-full bg-red-500';
      }

      const incomingNames = Array.isArray(data.participant_names) ? data.participant_names : [];
      const incomingKey = incomingNames.join('|');
      if (!namesLocked && incomingKey !== namesKey) {
        setWheelNames(incomingNames);
      }

      const w = data.last_winner;
      if (w && w.display_name) {
        const key = `${w.display_name}|${w.platform}|${w.drawn_at || ''}`;
        if (waitingWinnerState && expectedWinnerName && w.display_name === expectedWinnerName) {
          winnerKey = key;
          waitingWinnerState = false;
          expectedWinnerName = null;
          return;
        }
        if (!initialized) {
          winnerKey = key;
          if (elWinner) elWinner.textContent = w.display_name;
        } else if (key !== winnerKey) {
          winnerKey = key;
          if (!plannedDraw && phase === 'spinning') {
            startResolve(w.display_name, 1800);
            pendingWinner = null;
          } else if (!plannedDraw && phase !== 'resolving') {
            pendingWinner = w.display_name;
            startSpin();
          }
        }
      }

      initialized = true;
    }

    async function loadPreviewParticipants() {
      if (!previewMode) return;
      if (namesLocked) return;
      try {
        const resp = await fetch(`/giveaways/${giveawayId}/participants`, { credentials: 'same-origin' });
        if (!resp.ok) return;
        const rows = await resp.json();
        const list = Array.isArray(rows) ? rows.map((r) => (r && r.display_name ? String(r.display_name) : '')).filter(Boolean) : [];
        setWheelNames(list);
      } catch (_) {
      }
    }

    const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
    const ws = new WebSocket(`${scheme}://${location.host}/ws/overlay/roulette/${giveawayId}?token=${encodeURIComponent(token)}`);

    ws.onmessage = (event) => {
      const payload = JSON.parse(event.data);
      if (payload.type === 'draw_started') {
        startPlannedDraw(payload.winner_name, Number(payload.duration_ms || 4200));
        return;
      }

      const data = payload.type === 'state' ? payload.state : payload;
      if (!data) return;
      setBaseState(data);
    };

    window.addEventListener('message', (event) => {
      if (event.origin !== location.origin) return;
      const payload = event.data || {};
      if (payload.type === 'preview_draw_started') {
        startPlannedDraw(null, 0);
      }
    });

    loadPreviewParticipants();
    if (previewMode) {
      setInterval(loadPreviewParticipants, 6000);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
